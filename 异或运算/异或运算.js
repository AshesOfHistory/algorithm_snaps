// a ^ b   异或运算  =》  无进位相加  =》 相同取0，不同取1

// 0 ^ N  =>  N 
// N ^ N  =>  0
// 满足交换律和结合律  (a ^ b) ^ c  === a ^ (b ^ c)    取决于该位上有偶数个1（0）还是奇数个1（1）

// 综合运用1
// 不使用额外变量交换a和b
// 前提  a 与 b的指针指向不同的内存区域
// a = x    b = y
a = a ^ b  // a = x ^ y
b = a ^ b // b = x ^ y ^ y => x ^ (y ^ y) => x ^ 0 => x
a = a ^ b // a = x ^ y ^ x => (x ^ x) ^ y => 0 ^ y => y

function swap(a, b) {
  a = a ^ b
  b = a ^ b
  a = a ^ b
}

// 综合运用2
// 一个数组，只有一个数出现了奇数次，其他数字都出现了偶数次,找到该奇数次的数字
//   1, 2, 3, 2, 1, 3, 3, 4, 2, 4, 4, 2, 4
// =>(1, 1,) (2, 2, 2, 2,) (3, 3,) 3, (4, 4, 4, 4,) 
function findJiNum(arr) {
  let result = 0
  for (let i = 0; i < arr.length; i++) {
    result ^= arr[i]
  }
  return result
}


// 取出一个数字最右侧的1
// 反码  补码
// 二进制数取反+1  等于该数字的相反数
let num = 13
// -num = (~num) + 1
// 下面两种写法等价
x = num & ((~num) + 1)
x = num & (-num)

// 一个数组，a出现了k数次，其他数字都出现了m数次,找到这出现k数次的数字, m>1, k<m,  打印这两个数a, b，  要求时间复杂度O(N)  空间复杂度O(1)
// index % m !== 0 => a在index一定为1
// (num>>i) & 1 !== 0   => 该位是1  累加
// t[i] += (num>>i) & 1
// t[i] % m !== 0 => 数字在该位一定是1  
// ans = 0
// for循环
// ans |= (1 << i)



// 一个数组，a，b出现了奇数次，其他都出现了偶数次,找到这两种出现奇数次的数字,  打印这两个数a, b，  要求时间复杂度O(N)  空间复杂度O(1)
// eor = a != b  => 循环遍历该数组，得到 a ^ b !== 0 =>  找到该数字最右侧的1的index =>  a的二进制的index与b的二进制的index位置不一致
// eor1 => 只异或index位为1的数字 => 循环遍历该数组，得到a
// eor ^ eor1 => a ^ b ^ a => b